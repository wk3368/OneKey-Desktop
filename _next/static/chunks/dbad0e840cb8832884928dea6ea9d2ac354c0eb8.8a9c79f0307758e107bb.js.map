{"version":3,"sources":["webpack://_N_E/../suite/src/utils/wallet/exchangeFormUtils.ts","webpack://_N_E/../suite/src/actions/wallet/coinmarket/coinmarketTransactionBitcoinActions.ts","webpack://_N_E/../suite/src/actions/wallet/coinmarket/coinmarketTransactionEthereumActions.ts","webpack://_N_E/../suite/src/actions/wallet/coinmarket/coinmarketTransactionRippleActions.ts","webpack://_N_E/../suite/src/actions/wallet/coinmarket/coinmarketCommonActions.ts"],"names":["getExternalComposeOutput","account","network","address","amount","token","isMaxActive","isInvity","formattedToken","invityApiSymbolToSymbol","tokenInfo","tokens","find","t","symbol","decimals","amountInSatoshi","amountToSatoshi","output","type","composeTransaction","composeTransactionData","async","dispatch","feeInfo","addresses","utxo","composeOutputs","result","push","formattedAmount","networkAmountToSatoshi","getBitcoinComposeOutputs","length","predefinedLevels","levels","filter","l","label","selectedFee","feePerUnit","blocks","params","path","input","feeLevels","outputs","coin","response","TrezorConnect","success","notificationActions","error","payload","wrappedResponse","forEach","tx","index","feeLabel","r","custom","minFee","lastKnownFee","rangeGap","BigNumber","minus","gt","maxFee","customLevels","gte","toString","customLevelsResponse","customValid","findIndex","Object","keys","key","feePerByte","integerValue","ROUND_FLOOR","max","formatNetworkAmount","errorMessage","id","outputsWithFinalAddress","updatedOutputsCount","updatedOutputs","map","o","updated","calculate","availableBalance","feeLevel","feeInSatoshi","calculateEthFee","toWei","feeLimit","availableTokenBalance","balance","undefined","calculateMax","totalSpent","calculateTotal","isGreaterThan","payloadData","fee","bytes","transaction","inputs","script_type","verifyAddress","inExchange","getState","device","suite","getUnusedAddressFromAccount","networkType","useEmptyPassphrase","connected","available","modalPayload","addressPath","modalActions","buttonRequestHandler","event","code","fn","ethereumGetAddress","rippleGetAddress","getAddress","on","UI","REQUEST_BUTTON","off","COINMARKET_EXCHANGE","VERIFY_ADDRESS","COINMARKET_BUY","addressVerified","saveComposedTransaction","composedTransaction","COINMARKET_COMMON","SAVE_COMPOSED_TRANSACTION","saveTransactionReview","reviewData","SAVE_TRANSACTION_REVIEW","transactionBitcoinActions","ethereumDataHex","customFeeLimit","ERC20_GAS_LIMIT","estimatedFee","blockchainEstimateFee","request","specific","from","descriptor","getEthereumEstimateFeeParams","level","formatAmount","estimatedFeeLimit","values","toUpperCase","transactionEthereumActions","transactionRippleActions","signTransaction","signTransactionData","data","selectedAccount","wallet","transactionInfo","status","signEnhancement","ZEC_SIGN_ENHANCEMENT","sequence","signPayload","instance","state","signedTx","coinmarketCommonActions","serializedTx","transactions","chainId","pendingNonce","isPending","reduce","value","ethereumSpecific","Math","nonce","pendingNonceBig","misc","prepareEthereumTransaction","to","gasLimit","ETH_DEFAULT_GAS_LIMIT","gasPrice","ethereumSignTransaction","serializeEthereumTx","payment","destination","destinationTag","parseInt","extraFields","rippleSignTransaction","flags","XRP_FLAG","pushTransaction","sentTx","cancel","cancelSignTx","spentWithoutFee","txid","accountActions"],"mappings":"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","file":"static/chunks/dbad0e840cb8832884928dea6ea9d2ac354c0eb8.8a9c79f0307758e107bb.js","sourcesContent":["import { ExternalOutput } from '@wallet-types/sendForm';\nimport { amountToSatoshi, networkAmountToSatoshi } from '@wallet-utils/accountUtils';\nimport { ComposeOutput } from '@onekeyhq/connect';\nimport { ComposeTransactionData } from '@wallet-types/transaction';\nimport { invityApiSymbolToSymbol } from '@wallet-utils/coinmarket/coinmarketUtils';\n\nexport const getExternalComposeOutput = ({\n    account,\n    network,\n    address,\n    amount,\n    token,\n    isMaxActive,\n    isInvity,\n}: ComposeTransactionData) => {\n    const formattedToken = isInvity ? invityApiSymbolToSymbol(token) : token;\n    const tokenInfo = account.tokens?.find(t => t.symbol === formattedToken);\n    const decimals = tokenInfo ? tokenInfo.decimals : network.decimals;\n    const amountInSatoshi = amountToSatoshi(amount, decimals);\n    let output: ExternalOutput;\n    if (isMaxActive) {\n        if (address) {\n            output = {\n                type: 'send-max',\n                address,\n            };\n        } else {\n            output = {\n                type: 'send-max-noaddress',\n            };\n        }\n    } else if (address) {\n        output = {\n            type: 'external',\n            address,\n            amount: amountInSatoshi,\n        };\n    } else {\n        output = {\n            type: 'noaddress',\n            amount: amountInSatoshi,\n        };\n    }\n\n    return {\n        output,\n        tokenInfo,\n        decimals,\n    };\n};\n\nexport const getBitcoinComposeOutputs = ({\n    account,\n    address,\n    amount,\n    isMaxActive,\n}: ComposeTransactionData) => {\n    const result: ComposeOutput[] = [];\n\n    if (isMaxActive) {\n        if (address) {\n            result.push({\n                type: 'send-max',\n                address,\n            });\n        } else {\n            result.push({ type: 'send-max-noaddress' });\n        }\n    } else if (amount) {\n        const formattedAmount = networkAmountToSatoshi(amount, account.symbol);\n        if (address) {\n            result.push({\n                type: 'external',\n                address,\n                amount: formattedAmount,\n            });\n        } else {\n            result.push({\n                type: 'noaddress',\n                amount: formattedAmount,\n            });\n        }\n    }\n\n    return result;\n};\n","import TrezorConnect, { FeeLevel, SignTransaction, TxOutputType } from '@onekeyhq/connect';\nimport BigNumber from 'bignumber.js';\nimport {\n    ComposeTransactionData,\n    ReviewTransactionData,\n    SignTransactionData,\n} from '@wallet-types/transaction';\nimport * as notificationActions from '@suite-actions/notificationActions';\nimport { formatNetworkAmount } from '@wallet-utils/accountUtils';\nimport { getBitcoinComposeOutputs } from '@wallet-utils/exchangeFormUtils';\nimport { ZEC_SIGN_ENHANCEMENT } from '@wallet-constants/sendForm';\nimport { PrecomposedLevels, PrecomposedTransaction } from '@wallet-types/sendForm';\nimport { Dispatch, GetState } from '@suite-types';\nimport * as coinmarketCommonActions from '@wallet-actions/coinmarket/coinmarketCommonActions';\n\nexport const composeTransaction = (composeTransactionData: ComposeTransactionData) => async (\n    dispatch: Dispatch,\n) => {\n    const { account, feeInfo } = composeTransactionData;\n    if (!account.addresses || !account.utxo) return;\n\n    const composeOutputs = getBitcoinComposeOutputs(composeTransactionData);\n    if (composeOutputs.length < 1) return;\n\n    const predefinedLevels = feeInfo.levels.filter(l => l.label !== 'custom');\n    // in case when selectedFee is set to 'custom' construct this FeeLevel from values\n    if (composeTransactionData.selectedFee === 'custom') {\n        predefinedLevels.push({\n            label: 'custom',\n            feePerUnit: composeTransactionData.feePerUnit,\n            blocks: -1,\n        });\n    }\n    const params = {\n        account: {\n            path: account.path,\n            addresses: account.addresses,\n            // it is technically possible to have utxo with amount '0' see: https://tbtc1.trezor.io/tx/352873fe6cd5a83ca4b02737848d7d839aab864b8223c5ba7150ae35c22f4e38\n            // however they should be excluded to avoid increase fee\n            // TODO: this should be fixed in TrezorConnect + hd-wallet.composeTx? (connect throws: 'Segwit output without amount' error)\n            utxo: account.utxo.filter(input => input.amount !== '0'),\n        },\n        feeLevels: predefinedLevels,\n        outputs: composeOutputs,\n        coin: account.symbol,\n    };\n\n    const response = await TrezorConnect.composeTransaction({\n        ...params,\n        account: params.account, // needs to be present in order to correct resolve of @onekeyhq/connect params overload\n    });\n\n    if (!response.success) {\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: response.payload.error,\n            }),\n        );\n        return;\n    }\n\n    // wrap response into PrecomposedLevels object where key is a FeeLevel label\n    const wrappedResponse: PrecomposedLevels = {};\n    response.payload.forEach((tx, index) => {\n        const feeLabel = predefinedLevels[index].label as FeeLevel['label'];\n        wrappedResponse[feeLabel] = tx as PrecomposedTransaction;\n    });\n\n    const hasAtLeastOneValid = response.payload.find(r => r.type !== 'error');\n    // there is no valid tx in predefinedLevels and there is no custom level\n    if (!hasAtLeastOneValid && !wrappedResponse.custom) {\n        const { minFee } = feeInfo;\n        const lastKnownFee = predefinedLevels[predefinedLevels.length - 1].feePerUnit;\n        // define coefficient for maxFee\n        // NOTE: DOGE has very large values of FeeLevels, up to several thousands sat/B, rangeGap should be greater in this case otherwise calculation takes too long\n        // TODO: calculate rangeGap more precisely (percentage of range?)\n        const range = new BigNumber(lastKnownFee).minus(minFee);\n        const rangeGap = range.gt(1000) ? 1000 : 1;\n        let maxFee = new BigNumber(lastKnownFee).minus(rangeGap);\n        // generate custom levels in range from lastKnownFee minus customGap to feeInfo.minFee (coinInfo in @onekeyhq/connect)\n        const customLevels: FeeLevel[] = [];\n        while (maxFee.gte(minFee)) {\n            customLevels.push({ feePerUnit: maxFee.toString(), label: 'custom', blocks: -1 });\n            maxFee = maxFee.minus(rangeGap);\n        }\n\n        // check if any custom level is possible\n        const customLevelsResponse =\n            customLevels.length > 0\n                ? await TrezorConnect.composeTransaction({\n                      ...params,\n                      account: params.account, // needs to be present in order to correct resolve type of @onekeyhq/connect params overload\n                      feeLevels: customLevels,\n                  })\n                : ({ success: false } as const);\n\n        if (customLevelsResponse.success) {\n            const customValid = customLevelsResponse.payload.findIndex(r => r.type !== 'error');\n            if (customValid >= 0) {\n                wrappedResponse.custom = customLevelsResponse.payload[\n                    customValid\n                ] as PrecomposedTransaction;\n            }\n        }\n    }\n\n    // make sure that feePerByte is an integer (@onekeyhq/connect may return float)\n    // format max (@onekeyhq/connect sends it as satoshi)\n    // format errorMessage and catch unexpected error (other than AMOUNT_IS_NOT_ENOUGH)\n    Object.keys(wrappedResponse).forEach(key => {\n        const tx = wrappedResponse[key];\n        if (tx.type !== 'error') {\n            tx.feePerByte = new BigNumber(tx.feePerByte)\n                .integerValue(BigNumber.ROUND_FLOOR)\n                .toString();\n            if (typeof tx.max === 'string') {\n                tx.max = formatNetworkAmount(tx.max, account.symbol);\n            }\n        } else if (tx.error === 'NOT-ENOUGH-FUNDS') {\n            tx.errorMessage = { id: 'AMOUNT_IS_NOT_ENOUGH' };\n        } else {\n            // catch unexpected error\n            dispatch(\n                notificationActions.addToast({\n                    type: 'sign-tx-error',\n                    error: tx.error,\n                }),\n            );\n        }\n    });\n\n    return wrappedResponse;\n};\n\n// TODO - maybe move to some utils\nexport const outputsWithFinalAddress = (address: string, outputs: TxOutputType[]) => {\n    let updatedOutputsCount = 0;\n    const updatedOutputs = outputs.map(o => {\n        const updated = { ...o };\n        // find the output which has address, other outputs are change outputs, specified by address_n\n        if (o.address) {\n            updatedOutputsCount++;\n            updated.address = address;\n        }\n        return updated;\n    });\n    // sanity check\n    if (updatedOutputsCount !== 1) {\n        return undefined;\n    }\n    return updatedOutputs;\n};\n\nexport const signTransaction = (data: SignTransactionData) => async (\n    dispatch: Dispatch,\n    getState: GetState,\n) => {\n    const { selectedAccount } = getState().wallet;\n    const { device } = getState().suite;\n    const { transactionInfo, address } = data;\n    if (selectedAccount.status !== 'loaded' || !device || !transactionInfo) return;\n\n    // transactionInfo needs some additional changes:\n    const { account } = selectedAccount;\n    const { transaction } = transactionInfo;\n    let signEnhancement: Partial<SignTransaction> = {};\n\n    // enhance signTransaction params for zcash (version_group_id etc.)\n    if (account.symbol === 'zec') {\n        signEnhancement = ZEC_SIGN_ENHANCEMENT;\n    }\n\n    const updatedOutputs = outputsWithFinalAddress(address, transaction.outputs);\n    if (!updatedOutputs) {\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: 'Invalid transaction outputs',\n            }),\n        );\n        return;\n    }\n\n    // update inputs\n    // TODO: 0 amounts should be excluded together with \"exclude dustLimit\" feature and \"utxo picker\" feature in composeTransaction (above)\n    const inputs = transaction.inputs\n        .map(input => ({\n            ...input,\n        }))\n        .filter(input => input.amount !== '0'); // remove '0' amounts\n    inputs.forEach(input => {\n        if (!input.sequence) delete input.sequence;\n    });\n\n    const signPayload = {\n        device: {\n            path: device.path,\n            instance: device.instance,\n            state: device.state,\n        },\n        useEmptyPassphrase: device.useEmptyPassphrase,\n        outputs: updatedOutputs,\n        inputs,\n        coin: account.symbol,\n        ...signEnhancement,\n    };\n\n    const reviewData: ReviewTransactionData = {\n        signedTx: undefined,\n        transactionInfo: {\n            ...transactionInfo,\n            transaction: { ...transaction, inputs, outputs: updatedOutputs },\n        },\n    };\n    dispatch(coinmarketCommonActions.saveTransactionReview(reviewData));\n\n    const signedTx = await TrezorConnect.signTransaction(signPayload);\n\n    if (!signedTx.success) {\n        // catch manual error from ReviewTransaction modal\n        if (signedTx.payload.error === 'tx-cancelled') return;\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: signedTx.payload.error,\n            }),\n        );\n        return;\n    }\n\n    return {\n        ...reviewData,\n        signedTx: {\n            tx: signedTx.payload.serializedTx,\n            coin: account.symbol,\n        },\n    };\n};\n","import TrezorConnect, { FeeLevel, TokenInfo } from '@onekeyhq/connect';\nimport BigNumber from 'bignumber.js';\nimport { toWei } from 'web3-utils';\nimport { getExternalComposeOutput } from '@wallet-utils/exchangeFormUtils';\nimport {\n    ComposeTransactionData,\n    ReviewTransactionData,\n    SignTransactionData,\n} from '@wallet-types/transaction';\nimport * as notificationActions from '@suite-actions/notificationActions';\nimport {\n    calculateTotal,\n    calculateMax,\n    calculateEthFee,\n    serializeEthereumTx,\n    getEthereumEstimateFeeParams,\n    prepareEthereumTransaction,\n} from '@wallet-utils/sendFormUtils';\nimport { isPending } from '@wallet-utils/transactionUtils';\nimport { amountToSatoshi, formatAmount } from '@wallet-utils/accountUtils';\nimport { ETH_DEFAULT_GAS_LIMIT, ERC20_GAS_LIMIT } from '@wallet-constants/sendForm';\nimport { PrecomposedLevels, PrecomposedTransaction, ExternalOutput } from '@wallet-types/sendForm';\nimport { Dispatch, GetState } from '@suite-types';\nimport { outputsWithFinalAddress } from './coinmarketTransactionBitcoinActions';\nimport * as coinmarketCommonActions from '@wallet-actions/coinmarket/coinmarketCommonActions';\n\nconst calculate = (\n    availableBalance: string,\n    output: ExternalOutput,\n    feeLevel: FeeLevel,\n    token?: TokenInfo,\n): PrecomposedTransaction => {\n    const feeInSatoshi = calculateEthFee(\n        toWei(feeLevel.feePerUnit, 'gwei'),\n        feeLevel.feeLimit || '0',\n    );\n\n    let amount: string;\n    let max: string | undefined;\n    const availableTokenBalance = token\n        ? amountToSatoshi(token.balance!, token.decimals)\n        : undefined;\n    if (output.type === 'send-max' || output.type === 'send-max-noaddress') {\n        max = availableTokenBalance || calculateMax(availableBalance, feeInSatoshi);\n        amount = max;\n    } else {\n        amount = output.amount;\n    }\n\n    // total ETH spent (amount + fee), in ERC20 only fee\n    const totalSpent = new BigNumber(calculateTotal(token ? '0' : amount, feeInSatoshi));\n\n    if (totalSpent.isGreaterThan(availableBalance)) {\n        const error = token ? 'AMOUNT_NOT_ENOUGH_CURRENCY_FEE' : 'AMOUNT_IS_NOT_ENOUGH';\n        // errorMessage declared later\n        return { type: 'error', error, errorMessage: { id: error } } as const;\n    }\n\n    // validate if token balance is not 0 or lower than amount\n    if (\n        availableTokenBalance &&\n        (availableTokenBalance === '0' || new BigNumber(amount).gt(availableTokenBalance))\n    ) {\n        return {\n            type: 'error',\n            error: 'AMOUNT_IS_NOT_ENOUGH',\n            errorMessage: { id: 'AMOUNT_IS_NOT_ENOUGH' },\n        } as const;\n    }\n\n    const payloadData = {\n        type: 'nonfinal',\n        totalSpent: token ? amount : totalSpent.toString(),\n        max,\n        fee: feeInSatoshi,\n        feePerByte: feeLevel.feePerUnit,\n        feeLimit: feeLevel.feeLimit,\n        token,\n        bytes: 0, // TODO: calculate\n    } as const;\n\n    if (output.type === 'send-max' || output.type === 'external') {\n        return {\n            ...payloadData,\n            type: 'final',\n            // compatibility with BTC PrecomposedTransaction from @onekeyhq/connect\n            transaction: {\n                inputs: [],\n                outputs: [\n                    {\n                        address: output.address,\n                        amount,\n                        script_type: 'PAYTOADDRESS',\n                    },\n                ],\n            },\n        };\n    }\n\n    return payloadData;\n};\n\nexport const composeTransaction = (composeTransactionData: ComposeTransactionData) => async () => {\n    const { account, network, feeInfo, address, amount, ethereumDataHex } = composeTransactionData;\n    const composeOutputs = getExternalComposeOutput(composeTransactionData);\n    if (!composeOutputs) return; // no valid Output\n\n    const { output, tokenInfo, decimals } = composeOutputs;\n    const { availableBalance } = account;\n    let customFeeLimit: string | undefined;\n    // set gasLimit based on ERC20 transfer\n    if (tokenInfo) {\n        customFeeLimit = ERC20_GAS_LIMIT;\n    }\n\n    // gasLimit calculation based on address, amount and data size\n    // amount in essential for a proper calculation of gasLimit (via blockbook/geth)\n    const estimatedFee = await TrezorConnect.blockchainEstimateFee({\n        coin: account.symbol,\n        request: {\n            blocks: [2],\n            specific: {\n                from: account.descriptor,\n                ...getEthereumEstimateFeeParams(\n                    address || account.descriptor,\n                    tokenInfo,\n                    amount,\n                    ethereumDataHex,\n                ),\n            },\n        },\n    });\n\n    if (estimatedFee.success) {\n        customFeeLimit = estimatedFee.payload.levels[0].feeLimit;\n    } else {\n        // TODO: catch error from blockbook/geth (invalid contract, not enough balance...)\n    }\n\n    // FeeLevels are read-only\n    const levels = customFeeLimit ? feeInfo.levels.map(l => ({ ...l })) : feeInfo.levels;\n    const predefinedLevels = levels.filter(l => l.label !== 'custom');\n    // update predefined levels with customFeeLimit (gasLimit from data size or erc20 transfer)\n    if (customFeeLimit) {\n        predefinedLevels.forEach(l => (l.feeLimit = customFeeLimit));\n    }\n    // in case when selectedFee is set to 'custom' construct this FeeLevel from values\n    if (composeTransactionData.selectedFee === 'custom') {\n        predefinedLevels.push({\n            label: 'custom',\n            feePerUnit: composeTransactionData.feePerUnit,\n            feeLimit: composeTransactionData.feeLimit,\n            blocks: -1,\n        });\n    }\n\n    // wrap response into PrecomposedLevels object where key is a FeeLevel label\n    const wrappedResponse: PrecomposedLevels = {};\n    const response = predefinedLevels.map(level =>\n        calculate(availableBalance, output, level, tokenInfo),\n    );\n    response.forEach((tx, index) => {\n        const feeLabel = predefinedLevels[index].label as FeeLevel['label'];\n        wrappedResponse[feeLabel] = tx;\n    });\n\n    const hasAtLeastOneValid = response.find(r => r.type !== 'error');\n    // there is no valid tx in predefinedLevels and there is no custom level\n    if (!hasAtLeastOneValid && !wrappedResponse.custom) {\n        const { minFee } = feeInfo;\n        const lastKnownFee = predefinedLevels[predefinedLevels.length - 1].feePerUnit;\n        let maxFee = new BigNumber(lastKnownFee).minus(1);\n        // generate custom levels in range from lastKnownFee - 1 to feeInfo.minFee (coinInfo in @onekeyhq/connect)\n        const customLevels: FeeLevel[] = [];\n        while (maxFee.gte(minFee)) {\n            customLevels.push({\n                feePerUnit: maxFee.toString(),\n                feeLimit: predefinedLevels[0].feeLimit,\n                label: 'custom',\n                blocks: -1,\n            });\n            maxFee = maxFee.minus(1);\n        }\n\n        // check if any custom level is possible\n        const customLevelsResponse = customLevels.map(level =>\n            calculate(availableBalance, output, level, tokenInfo),\n        );\n\n        const customValid = customLevelsResponse.findIndex(r => r.type !== 'error');\n        if (customValid >= 0) {\n            wrappedResponse.custom = customLevelsResponse[customValid];\n        }\n    }\n\n    // format max (calculate sends it as satoshi)\n    // update errorMessage values (symbol)\n    Object.keys(wrappedResponse).forEach(key => {\n        const tx = wrappedResponse[key];\n        if (tx.type !== 'error') {\n            tx.max = tx.max ? formatAmount(tx.max, decimals) : undefined;\n            tx.estimatedFeeLimit = customFeeLimit;\n        }\n        if (tx.type === 'error' && tx.error === 'AMOUNT_NOT_ENOUGH_CURRENCY_FEE') {\n            tx.errorMessage = {\n                id: 'AMOUNT_NOT_ENOUGH_CURRENCY_FEE',\n                values: { symbol: network.symbol.toUpperCase() },\n            };\n        }\n    });\n\n    return wrappedResponse;\n};\n\nexport const signTransaction = (data: SignTransactionData) => async (\n    dispatch: Dispatch,\n    getState: GetState,\n) => {\n    const { selectedAccount, transactions } = getState().wallet;\n    const { device } = getState().suite;\n    if (selectedAccount.status !== 'loaded' || !device || !data.transactionInfo) return;\n\n    const { account } = selectedAccount;\n    if (account.networkType !== 'ethereum' || !data.network.chainId) return;\n\n    // Ethereum account `misc.nonce` is not updated before pending tx is mined\n    // Calculate `pendingNonce`: greatest value in pending tx + 1\n    // This may lead to unexpected/unwanted behavior\n    // whenever pending tx gets rejected all following txs (with higher nonce) will be rejected as well\n    const pendingTxs = (transactions.transactions[account.key] || []).filter(isPending);\n    const pendingNonce = pendingTxs.reduce((value, tx) => {\n        if (!tx.ethereumSpecific) return value;\n        return Math.max(value, tx.ethereumSpecific.nonce + 1);\n    }, 0);\n    const pendingNonceBig = new BigNumber(pendingNonce);\n    const nonce =\n        pendingNonceBig.gt(0) && pendingNonceBig.gt(account.misc.nonce)\n            ? pendingNonceBig.toString()\n            : account.misc.nonce;\n\n    const updatedOutputs = outputsWithFinalAddress(\n        data.address,\n        data.transactionInfo.transaction.outputs,\n    );\n    if (!updatedOutputs) {\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: 'Invalid transaction outputs',\n            }),\n        );\n        return;\n    }\n\n    const decimals = data.transactionInfo.token\n        ? data.transactionInfo.token.decimals\n        : data.network.decimals;\n    const transaction = prepareEthereumTransaction({\n        token: data.transactionInfo.token,\n        chainId: data.network.chainId,\n        to: data.address,\n        amount: formatAmount(data.transactionInfo.transaction.outputs[0].amount, decimals),\n        gasLimit: data.transactionInfo.feeLimit || ETH_DEFAULT_GAS_LIMIT,\n        gasPrice: data.transactionInfo.feePerByte,\n        nonce,\n    });\n\n    const reviewData: ReviewTransactionData = {\n        signedTx: undefined,\n        transactionInfo: {\n            ...data.transactionInfo,\n            transaction: { ...data.transactionInfo.transaction, outputs: updatedOutputs },\n        },\n    };\n    await dispatch(coinmarketCommonActions.saveTransactionReview(reviewData));\n\n    const signedTx = await TrezorConnect.ethereumSignTransaction({\n        device: {\n            path: device.path,\n            instance: device.instance,\n            state: device.state,\n        },\n        useEmptyPassphrase: device.useEmptyPassphrase,\n        path: account.path,\n        transaction,\n    });\n\n    if (!signedTx.success) {\n        // catch manual error from ReviewTransaction modal\n        if (signedTx.payload.error === 'tx-cancelled') return;\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: signedTx.payload.error,\n            }),\n        );\n        return;\n    }\n\n    return {\n        ...reviewData,\n        signedTx: {\n            tx: serializeEthereumTx({\n                ...transaction,\n                ...signedTx.payload,\n            }),\n            coin: account.symbol,\n        },\n    };\n};\n","import TrezorConnect, { FeeLevel, RipplePayment } from '@onekeyhq/connect';\nimport BigNumber from 'bignumber.js';\nimport {\n    ComposeTransactionData,\n    ReviewTransactionData,\n    SignTransactionData,\n} from '@wallet-types/transaction';\nimport * as notificationActions from '@suite-actions/notificationActions';\nimport { calculateTotal, calculateMax } from '@wallet-utils/sendFormUtils';\nimport { getExternalComposeOutput } from '@wallet-utils/exchangeFormUtils';\nimport { formatNetworkAmount } from '@wallet-utils/accountUtils';\nimport { XRP_FLAG } from '@wallet-constants/sendForm';\nimport { PrecomposedLevels, PrecomposedTransaction, ExternalOutput } from '@wallet-types/sendForm';\nimport { Dispatch, GetState } from '@suite-types';\nimport { outputsWithFinalAddress } from './coinmarketTransactionBitcoinActions';\nimport * as coinmarketCommonActions from '@wallet-actions/coinmarket/coinmarketCommonActions';\n\nconst calculate = (\n    availableBalance: string,\n    output: ExternalOutput,\n    feeLevel: FeeLevel,\n): PrecomposedTransaction => {\n    const feeInSatoshi = feeLevel.feePerUnit;\n\n    let amount: string;\n    let max: string | undefined;\n    if (output.type === 'send-max' || output.type === 'send-max-noaddress') {\n        max = calculateMax(availableBalance, feeInSatoshi);\n        amount = max;\n    } else {\n        amount = output.amount;\n    }\n    const totalSpent = new BigNumber(calculateTotal(amount, feeInSatoshi));\n\n    if (totalSpent.isGreaterThan(availableBalance)) {\n        return {\n            type: 'error',\n            error: 'AMOUNT_IS_NOT_ENOUGH',\n            errorMessage: { id: 'AMOUNT_IS_NOT_ENOUGH' },\n        } as const;\n    }\n\n    const payloadData = {\n        type: 'nonfinal',\n        totalSpent: totalSpent.toString(),\n        max,\n        fee: feeInSatoshi,\n        feePerByte: feeLevel.feePerUnit,\n        bytes: 0, // TODO: calculate\n    } as const;\n\n    if (output.type === 'send-max' || output.type === 'external') {\n        return {\n            ...payloadData,\n            type: 'final',\n            // compatibility with BTC PrecomposedTransaction from @onekeyhq/connect\n            transaction: {\n                inputs: [],\n                outputs: [\n                    {\n                        address: output.address,\n                        amount,\n                        // eslint-disable-next-line @typescript-eslint/naming-convention\n                        script_type: 'PAYTOADDRESS',\n                    },\n                ],\n            },\n        };\n    }\n    return payloadData;\n};\n\nexport const composeTransaction = (composeTransactionData: ComposeTransactionData) => () => {\n    const { account, feeInfo } = composeTransactionData;\n    const composeOutputs = getExternalComposeOutput(composeTransactionData);\n    if (!composeOutputs) return; // no valid Output\n\n    const { output } = composeOutputs;\n    const { availableBalance } = account;\n    const predefinedLevels = feeInfo.levels.filter(l => l.label !== 'custom');\n    // in case when selectedFee is set to 'custom' construct this FeeLevel from values\n    if (composeTransactionData.selectedFee === 'custom') {\n        predefinedLevels.push({\n            label: 'custom',\n            feePerUnit: composeTransactionData.feePerUnit,\n            blocks: -1,\n        });\n    }\n\n    // wrap response into PrecomposedLevels object where key is a FeeLevel label\n    const wrappedResponse: PrecomposedLevels = {};\n    const response = predefinedLevels.map(level => calculate(availableBalance, output, level));\n    response.forEach((tx, index) => {\n        const feeLabel = predefinedLevels[index].label as FeeLevel['label'];\n        wrappedResponse[feeLabel] = tx;\n    });\n\n    const hasAtLeastOneValid = response.find(r => r.type !== 'error');\n    // there is no valid tx in predefinedLevels and there is no custom level\n    if (!hasAtLeastOneValid && !wrappedResponse.custom) {\n        const { minFee } = feeInfo;\n        const lastKnownFee = predefinedLevels[predefinedLevels.length - 1].feePerUnit;\n        let maxFee = new BigNumber(lastKnownFee).minus(1);\n        // generate custom levels in range from lastKnownFee -1 to feeInfo.minFee (coinInfo in @onekeyhq/connect)\n        const customLevels: FeeLevel[] = [];\n        while (maxFee.gte(minFee)) {\n            customLevels.push({ feePerUnit: maxFee.toString(), label: 'custom', blocks: -1 });\n            maxFee = maxFee.minus(1);\n        }\n\n        const customLevelsResponse = customLevels.map(level =>\n            calculate(availableBalance, output, level),\n        );\n\n        const customValid = customLevelsResponse.findIndex(r => r.type !== 'error');\n        if (customValid >= 0) {\n            wrappedResponse.custom = customLevelsResponse[customValid];\n        }\n    }\n\n    // format max (calculate sends it as satoshi)\n    // update errorMessage values (reserve)\n    Object.keys(wrappedResponse).forEach(key => {\n        const tx = wrappedResponse[key];\n        if (tx.type !== 'error' && tx.max) {\n            tx.max = formatNetworkAmount(tx.max, account.symbol);\n        }\n    });\n\n    return wrappedResponse;\n};\n\nexport const signTransaction = (data: SignTransactionData) => async (\n    dispatch: Dispatch,\n    getState: GetState,\n) => {\n    const { selectedAccount } = getState().wallet;\n    const { device } = getState().suite;\n    if (selectedAccount.status !== 'loaded' || !device || !data.transactionInfo) return;\n    const { account } = selectedAccount;\n    if (account.networkType !== 'ripple') return;\n\n    const updatedOutputs = outputsWithFinalAddress(\n        data.address,\n        data.transactionInfo.transaction.outputs,\n    );\n    if (!updatedOutputs) {\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: 'Invalid transaction outputs',\n            }),\n        );\n        return;\n    }\n\n    const payment: RipplePayment = {\n        destination: data.address,\n        amount: data.transactionInfo.transaction.outputs[0].amount,\n    };\n\n    if (data.destinationTag) {\n        payment.destinationTag = parseInt(data.destinationTag, 10);\n    }\n\n    const reviewData: ReviewTransactionData = {\n        signedTx: undefined,\n        transactionInfo: {\n            ...data.transactionInfo,\n            transaction: { ...data.transactionInfo.transaction, outputs: updatedOutputs },\n        },\n        extraFields: {\n            destinationTag: data.destinationTag || undefined,\n        },\n    };\n\n    dispatch(coinmarketCommonActions.saveTransactionReview(reviewData));\n\n    const signedTx = await TrezorConnect.rippleSignTransaction({\n        device: {\n            path: device.path,\n            instance: device.instance,\n            state: device.state,\n        },\n        useEmptyPassphrase: device.useEmptyPassphrase,\n        path: account.path,\n        transaction: {\n            fee: data.transactionInfo.feePerByte,\n            flags: XRP_FLAG,\n            sequence: account.misc.sequence,\n            payment,\n        },\n    });\n    if (!signedTx.success) {\n        // catch manual error from ReviewTransaction modal\n        if (signedTx.payload.error === 'tx-cancelled') return;\n        dispatch(\n            notificationActions.addToast({\n                type: 'sign-tx-error',\n                error: signedTx.payload.error,\n            }),\n        );\n        return;\n    }\n\n    return {\n        ...reviewData,\n        signedTx: {\n            tx: signedTx.payload.serializedTx,\n            coin: account.symbol,\n        },\n    };\n};\n","import TrezorConnect, { UI, ButtonRequestMessage } from '@onekeyhq/connect';\nimport * as coinmarketCommonActions from '@wallet-actions/coinmarket/coinmarketCommonActions';\nimport { formatNetworkAmount, formatAmount } from '@wallet-utils/accountUtils';\nimport BigNumber from 'bignumber.js';\nimport {\n    ComposeTransactionData,\n    ReviewTransactionData,\n    SignTransactionData,\n    SignedTx,\n} from '@wallet-types/transaction';\nimport { GetState, Dispatch } from '@suite-types';\nimport * as accountActions from '@wallet-actions/accountActions';\nimport * as notificationActions from '@suite-actions/notificationActions';\nimport * as transactionBitcoinActions from './coinmarketTransactionBitcoinActions';\nimport * as transactionEthereumActions from './coinmarketTransactionEthereumActions';\nimport * as transactionRippleActions from './coinmarketTransactionRippleActions';\nimport * as modalActions from '@suite-actions/modalActions';\nimport { PrecomposedTransactionFinal } from '@wallet-types/sendForm';\nimport { COINMARKET_BUY, COINMARKET_EXCHANGE, COINMARKET_COMMON } from '../constants';\nimport { getUnusedAddressFromAccount } from '@wallet-utils/coinmarket/coinmarketUtils';\nimport { Account } from '@wallet-types';\n\nexport type CoinmarketCommonAction =\n    | { type: typeof COINMARKET_COMMON.SAVE_TRANSACTION_REVIEW; reviewData: ReviewTransactionData }\n    | {\n          type: typeof COINMARKET_COMMON.SAVE_COMPOSED_TRANSACTION;\n          composedTransaction: PrecomposedTransactionFinal;\n      };\n\nexport const verifyAddress = (account: Account, inExchange = false) => async (\n    dispatch: Dispatch,\n    getState: GetState,\n) => {\n    const { device } = getState().suite;\n    if (!device || !account) return;\n    const { path, address } = getUnusedAddressFromAccount(account);\n    if (!path || !address) return;\n\n    const { networkType, symbol } = account;\n    const { useEmptyPassphrase, connected, available } = device;\n\n    const modalPayload = {\n        device,\n        address,\n        networkType,\n        symbol,\n        addressPath: path,\n    };\n\n    // Show warning when device is not connected\n    if (!connected || !available) {\n        dispatch(\n            modalActions.openModal({\n                type: 'unverified-address',\n                ...modalPayload,\n            }),\n        );\n        return;\n    }\n\n    const params = {\n        device,\n        path,\n        useEmptyPassphrase,\n        coin: account.symbol,\n    };\n\n    // catch button request and open modal\n    const buttonRequestHandler = (event: ButtonRequestMessage['payload']) => {\n        if (!event || event.code !== 'ButtonRequest_Address') return;\n        dispatch(\n            modalActions.openModal({\n                type: 'address',\n                ...modalPayload,\n            }),\n        );\n    };\n\n    let fn;\n    switch (networkType) {\n        case 'ethereum':\n            fn = TrezorConnect.ethereumGetAddress;\n            break;\n        case 'ripple':\n            fn = TrezorConnect.rippleGetAddress;\n            break;\n        case 'bitcoin':\n            fn = TrezorConnect.getAddress;\n            break;\n        default:\n            fn = () => ({\n                success: false,\n                payload: { error: 'Method for getAddress not defined', code: undefined },\n            });\n            break;\n    }\n\n    TrezorConnect.on(UI.REQUEST_BUTTON, buttonRequestHandler);\n    const response = await fn(params);\n    TrezorConnect.off(UI.REQUEST_BUTTON, buttonRequestHandler);\n\n    if (response.success) {\n        dispatch({\n            type: inExchange ? COINMARKET_EXCHANGE.VERIFY_ADDRESS : COINMARKET_BUY.VERIFY_ADDRESS,\n            addressVerified: address,\n        });\n    } else {\n        // special case: device no-backup permissions not granted\n        if (response.payload.code === 'Method_PermissionsNotGranted') return;\n\n        dispatch(\n            notificationActions.addToast({\n                type: 'verify-address-error',\n                error: response.payload.error,\n            }),\n        );\n    }\n};\n\nexport const saveComposedTransaction = (\n    composedTransaction: PrecomposedTransactionFinal,\n): CoinmarketCommonAction => ({\n    type: COINMARKET_COMMON.SAVE_COMPOSED_TRANSACTION,\n    composedTransaction,\n});\n\nexport const saveTransactionReview = (\n    reviewData: ReviewTransactionData,\n): CoinmarketCommonAction => ({\n    type: COINMARKET_COMMON.SAVE_TRANSACTION_REVIEW,\n    reviewData,\n});\n\nexport const composeTransaction = (composeTransactionData: ComposeTransactionData) => (\n    dispatch: Dispatch,\n) => {\n    const {\n        account: { networkType },\n    } = composeTransactionData;\n\n    if (networkType === 'bitcoin') {\n        return dispatch(transactionBitcoinActions.composeTransaction(composeTransactionData));\n    }\n\n    if (networkType === 'ethereum') {\n        return dispatch(transactionEthereumActions.composeTransaction(composeTransactionData));\n    }\n\n    if (networkType === 'ripple') {\n        return dispatch(transactionRippleActions.composeTransaction(composeTransactionData));\n    }\n};\n\nexport const signTransaction = (signTransactionData: SignTransactionData) => async (\n    dispatch: Dispatch,\n) => {\n    const { account } = signTransactionData;\n\n    if (!account) return;\n\n    let reviewData: ReviewTransactionData | undefined;\n\n    if (account.networkType === 'bitcoin') {\n        reviewData = await dispatch(transactionBitcoinActions.signTransaction(signTransactionData));\n    }\n\n    if (account.networkType === 'ethereum') {\n        reviewData = await dispatch(\n            transactionEthereumActions.signTransaction(signTransactionData),\n        );\n    }\n\n    if (account.networkType === 'ripple') {\n        reviewData = await dispatch(transactionRippleActions.signTransaction(signTransactionData));\n    }\n\n    if (!reviewData?.signedTx?.tx) return;\n\n    await dispatch(coinmarketCommonActions.saveTransactionReview(reviewData));\n\n    const decision = await dispatch(\n        modalActions.openDeferredModal({ type: 'coinmarket-review-transaction' }),\n    );\n\n    if (decision && reviewData.transactionInfo) {\n        return dispatch(coinmarketCommonActions.pushTransaction(reviewData));\n    }\n};\n\nexport const cancelSignTx = (signedTx: SignedTx) => (dispatch: Dispatch) => {\n    if (!signedTx) {\n        TrezorConnect.cancel('tx-cancelled');\n        return;\n    }\n    // otherwise just close modal\n    dispatch(modalActions.onCancel());\n};\n\nexport const pushTransaction = (reviewData: ReviewTransactionData) => async (\n    dispatch: Dispatch,\n    getState: GetState,\n) => {\n    const { account } = getState().wallet.selectedAccount;\n    const { device } = getState().suite;\n    const { signedTx, transactionInfo } = reviewData;\n\n    if (!signedTx || !transactionInfo || !account) return false;\n\n    const sentTx = await TrezorConnect.pushTransaction(signedTx);\n\n    // close modal regardless result\n    dispatch(cancelSignTx(signedTx));\n\n    const { token } = transactionInfo;\n    const spentWithoutFee = !token\n        ? new BigNumber(transactionInfo.totalSpent).minus(transactionInfo.fee).toString()\n        : '0';\n    // get total amount without fee OR token amount\n    const formattedAmount = token\n        ? `${formatAmount(\n              transactionInfo.totalSpent,\n              token.decimals,\n          )} ${token.symbol!.toUpperCase()}`\n        : formatNetworkAmount(spentWithoutFee, account.symbol, true);\n\n    if (sentTx.success) {\n        dispatch(\n            notificationActions.addToast({\n                type: 'tx-sent',\n                formattedAmount,\n                device,\n                descriptor: account.descriptor,\n                symbol: account.symbol,\n                txid: sentTx.payload.txid,\n            }),\n        );\n\n        dispatch(accountActions.fetchAndUpdateAccount(account));\n    } else {\n        dispatch(\n            notificationActions.addToast({ type: 'sign-tx-error', error: sentTx.payload.error }),\n        );\n    }\n\n    return sentTx.success;\n};\n"],"sourceRoot":""}