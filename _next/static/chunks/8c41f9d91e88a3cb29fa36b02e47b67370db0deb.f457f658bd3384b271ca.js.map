{"version":3,"sources":["webpack://_N_E/../suite/src/hooks/wallet/useAccounts.ts","webpack://_N_E/../suite/src/hooks/wallet/useFiatValue.ts","webpack://_N_E/../suite/src/hooks/wallet/useSendForm.ts","webpack://_N_E/../suite/src/hooks/wallet/useSendFormFields.ts","webpack://_N_E/../suite/src/hooks/wallet/useSendFormCompose.ts","webpack://_N_E/../suite/src/hooks/wallet/useSendFormOutputs.ts","webpack://_N_E/../suite/src/hooks/wallet/useSendFormImport.ts"],"names":["useAccounts","discovery","accounts","setAccounts","useState","device","accountsState","useSelector","state","suite","wallet","useEffect","deviceAccounts","accountUtils","failedAccounts","sortedAccounts","concat","useFastAccounts","useMemo","useFiatValue","fiat","localCurrency","settings","SendContext","createContext","displayName","getStateFromProps","props","account","network","selectedAccount","symbol","networkType","coinFees","fees","levels","getFeeLevels","feeInfo","feeOutdated","fiatRates","coins","find","item","localCurrencyOption","value","label","toUpperCase","isLoading","isDirty","online","useSendForm","setState","draft","useRef","undefined","getDraft","saveDraft","removeDraft","getLastUsedFeeLevel","setLastUsedFeeLevel","signTransaction","useActions","sendFormActions","walletSettingsActions","useFormMethods","useForm","mode","shouldUnregister","control","reset","register","getValues","errors","outputsFieldArray","useFieldArray","name","getLoadedValues","useCallback","loadedState","feeEnhancement","selectedFee","lastUsedFee","feePerUnit","feeLimit","currency","DEFAULT_VALUES","options","isFeatureEnabled","features","includes","outputs","DEFAULT_PAYMENT","getDefaultValues","updateContext","sendFormUtils","setValue","clearErrors","calculateFiat","outputIndex","amount","output","type","inputName","length","current","fiatValue","toFiatCurrency","rates","shouldValidate","setAmount","shouldDirty","setMax","active","resetDefaultValue","fieldName","defaultValuesRef","getDefaultValue","fallbackValue","stateValue","toggleOption","option","enabledOptions","isEnabled","filter","o","useSendFormFields","composeDraft","draftSaveRequest","setDraftSaveRequest","composeRequest","composedLevels","setComposedLevels","onFeeLevelChange","setError","composeRequestRef","composeRequestID","composeField","setComposeField","debounce","useAsyncDebounce","composeTransaction","async","result","values","processComposeRequest","resultID","Object","keys","updateComposedValues","composed","error","errorMessage","message","forEach","_","i","console","warn","composeErrors","findComposeErrors","estimatedFeeLimit","setMaxOutputId","max","nearest","key","feePerByte","prev","prevLevel","custom","currentLevel","field","useSendFormCompose","sendFormOutputs","unregister","addOutput","append","removeOutput","index","remove","fields","_output","addOpReturn","lastOutput","address","DEFAULT_OPRETURN","removeOpReturn","useSendFormOutputs","changeFeeLevel","useFees","defaultValue","saveLastUsedFee","onChange","resetContext","importTransaction","tokens","importRequest","map","toLowerCase","FIAT","currencies","c","fromFiatCurrency","decimals","token","t","useSendFormImport","sign","composedTx","typedRegister","rules","storedState","loadTransaction","trigger","useSendFormContext","ctx","useContext","Error"],"mappings":"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","file":"static/chunks/8c41f9d91e88a3cb29fa36b02e47b67370db0deb.f457f658bd3384b271ca.js","sourcesContent":["import { useState, useEffect, useMemo } from 'react';\nimport { useSelector } from '@suite-hooks';\nimport { Account, Discovery } from '@wallet-types';\nimport * as accountUtils from '@wallet-utils/accountUtils';\n\nexport const useAccounts = (discovery?: Discovery) => {\n    const [accounts, setAccounts] = useState<Account[]>([]);\n\n    const { device, accountsState } = useSelector(state => ({\n        device: state.suite.device,\n        accountsState: state.wallet.accounts,\n    }));\n\n    useEffect(() => {\n        if (device) {\n            const deviceAccounts = accountUtils.getAllAccounts(device.state, accountsState);\n            const failedAccounts = discovery ? accountUtils.getFailedAccounts(discovery) : [];\n            const sortedAccounts = accountUtils.sortByCoin(deviceAccounts.concat(failedAccounts));\n            setAccounts(sortedAccounts);\n        }\n    }, [device, discovery, accountsState]);\n\n    return {\n        accounts,\n    };\n};\n\nexport const useFastAccounts = () => {\n    const { device, accounts } = useSelector(state => ({\n        device: state.suite.device,\n        accounts: state.wallet.accounts,\n    }));\n    const deviceAccounts = useMemo(\n        () => (device ? accountUtils.getAllAccounts(device.state, accounts) : []),\n        [accounts, device],\n    );\n    return deviceAccounts;\n};\n","import { useSelector } from '@suite-hooks';\n\n// TODO: do the calculation here\nexport const useFiatValue = () => {\n    const { fiat, localCurrency } = useSelector(state => ({\n        fiat: state.wallet.fiat,\n        localCurrency: state.wallet.settings.localCurrency,\n    }));\n    return {\n        fiat,\n        localCurrency,\n    };\n};\n","import { createContext, useContext, useCallback, useState, useEffect, useRef } from 'react';\nimport { useForm, useFieldArray } from 'react-hook-form';\nimport { useActions } from '@suite-hooks';\nimport * as sendFormActions from '@wallet-actions/sendFormActions';\nimport * as walletSettingsActions from '@settings-actions/walletSettingsActions';\nimport { DEFAULT_PAYMENT, DEFAULT_VALUES } from '@wallet-constants/sendForm';\nimport {\n    UseSendFormProps,\n    UseSendFormState,\n    FormState,\n    SendContextValues,\n    Output,\n} from '@wallet-types/sendForm';\nimport { isEnabled as isFeatureEnabled } from '@suite-utils/features';\n\nimport { getFeeLevels } from '@wallet-utils/sendFormUtils';\nimport { useSendFormOutputs } from './useSendFormOutputs';\nimport { useSendFormFields } from './useSendFormFields';\nimport { useSendFormCompose } from './useSendFormCompose';\nimport { useSendFormImport } from './useSendFormImport';\nimport { useFees } from './form/useFees';\n\nexport const SendContext = createContext<SendContextValues | null>(null);\nSendContext.displayName = 'SendContext';\n\nconst getDefaultValues = (\n    currency: Output['currency'],\n    network: UseSendFormState['network'],\n): FormState => {\n    return {\n        ...DEFAULT_VALUES,\n        options:\n            isFeatureEnabled('RBF') && network.features?.includes('rbf')\n                ? ['bitcoinRBF', 'broadcast']\n                : ['broadcast'],\n        outputs: [{ ...DEFAULT_PAYMENT, currency }],\n    };\n};\n\n// convert UseSendFormProps to UseSendFormState\nconst getStateFromProps = (props: UseSendFormProps) => {\n    const { account, network } = props.selectedAccount;\n    const { symbol, networkType } = account;\n    const coinFees = props.fees[symbol];\n    const levels = getFeeLevels(networkType, coinFees);\n    const feeInfo = { ...coinFees, levels };\n    const fiatRates = props.fiat.coins.find(item => item.symbol === symbol);\n    const localCurrencyOption = {\n        value: props.localCurrency,\n        label: props.localCurrency.toUpperCase(),\n    };\n    return {\n        account,\n        network,\n        coinFees,\n        feeInfo,\n        feeOutdated: false,\n        fiatRates,\n        localCurrencyOption,\n        isLoading: false,\n        isDirty: false,\n        online: props.online,\n    };\n};\n\n// Mounted in top level index: @wallet-views/send\n// return SendContextValues used by SendFormContext in all nested children components of @wallet-views/send\n// SendContextValues is a combination of `react-hook-form` methods with custom callbacks and utils\n// see: ./packages/suite/docs/send/ARCHITECTURE.md\n\nexport const useSendForm = (props: UseSendFormProps): SendContextValues => {\n    // public variables, exported to SendFormContext\n    const [state, setState] = useState<UseSendFormState>(getStateFromProps(props));\n\n    // private variables, used inside sendForm hook\n    const draft = useRef<FormState | undefined>(undefined);\n    const {\n        getDraft,\n        saveDraft,\n        removeDraft,\n        getLastUsedFeeLevel,\n        setLastUsedFeeLevel,\n        signTransaction,\n    } = useActions({\n        getDraft: sendFormActions.getDraft,\n        saveDraft: sendFormActions.saveDraft,\n        removeDraft: sendFormActions.removeDraft,\n        getLastUsedFeeLevel: walletSettingsActions.getLastUsedFeeLevel,\n        setLastUsedFeeLevel: walletSettingsActions.setLastUsedFeeLevel,\n        signTransaction: sendFormActions.signTransaction,\n    });\n\n    const { localCurrencyOption } = state;\n\n    // register `react-hook-form`, defaultValues are set later in \"loadDraft\" useEffect block\n    const useFormMethods = useForm<FormState>({ mode: 'onChange', shouldUnregister: false });\n\n    const { control, reset, register, getValues, errors } = useFormMethods;\n\n    // register array fields (outputs array in react-hook-form)\n    const outputsFieldArray = useFieldArray<Output>({\n        control,\n        name: 'outputs',\n    });\n\n    // enhance DEFAULT_VALUES with last remembered FeeLevel and localCurrencyOption\n    // used in \"loadDraft\" useEffect and \"importTransaction\" callback\n    const getLoadedValues = useCallback(\n        (loadedState?: Partial<FormState>) => {\n            const feeEnhancement: Partial<FormState> = {};\n            if (!loadedState || !loadedState.selectedFee) {\n                const lastUsedFee = getLastUsedFeeLevel();\n                if (lastUsedFee) {\n                    feeEnhancement.selectedFee = lastUsedFee.label;\n                    if (lastUsedFee.label === 'custom') {\n                        feeEnhancement.feePerUnit = lastUsedFee.feePerUnit;\n                        feeEnhancement.feeLimit = lastUsedFee.feeLimit;\n                    }\n                }\n            }\n            return {\n                ...getDefaultValues(localCurrencyOption, state.network),\n                ...loadedState,\n                ...feeEnhancement,\n            };\n        },\n        [getLastUsedFeeLevel, localCurrencyOption, state.network],\n    );\n\n    // update custom values\n    const updateContext = useCallback(\n        (value: Partial<UseSendFormState>) => {\n            setState({\n                ...state,\n                ...value,\n            });\n        },\n        [state],\n    );\n\n    // declare sendFormUtils, sub-hook of useSendForm\n    const sendFormUtils = useSendFormFields({\n        ...useFormMethods,\n        fiatRates: state.fiatRates,\n    });\n\n    // declare sendFormCompose, sub-hook of useSendForm\n    const {\n        composeDraft,\n        draftSaveRequest,\n        setDraftSaveRequest,\n        composeRequest,\n        composedLevels,\n        setComposedLevels,\n        onFeeLevelChange,\n    } = useSendFormCompose({\n        ...useFormMethods,\n        state,\n        account: props.selectedAccount.account,\n        updateContext,\n        setAmount: sendFormUtils.setAmount,\n    });\n\n    // declare useSendFormOutputs, sub-hook of useSendForm\n    const sendFormOutputs = useSendFormOutputs({\n        ...useFormMethods,\n        outputsFieldArray,\n        localCurrencyOption,\n        composeRequest,\n    });\n\n    // sub-hook\n    const { changeFeeLevel } = useFees({\n        defaultValue: undefined,\n        feeInfo: state.feeInfo,\n        saveLastUsedFee: true,\n        onChange: onFeeLevelChange,\n        composedLevels,\n        composeRequest,\n        ...useFormMethods,\n    });\n\n    const resetContext = useCallback(() => {\n        setComposedLevels(undefined);\n        removeDraft(); // reset draft\n        setLastUsedFeeLevel(); // reset last known FeeLevel\n        setState(getStateFromProps(props)); // resetting state will trigger \"loadDraft\" useEffect block, which will reset FormState to default\n    }, [props, removeDraft, setLastUsedFeeLevel, setComposedLevels]);\n\n    // declare useSendFormImport, sub-hook of useSendForm\n    const { importTransaction } = useSendFormImport({\n        network: state.network,\n        tokens: state.account.tokens,\n        fiatRates: state.fiatRates,\n        localCurrencyOption,\n    });\n\n    const loadTransaction = async () => {\n        const outputs = await importTransaction();\n        if (!outputs) return; // ignore empty result (cancelled or error)\n        setComposedLevels(undefined);\n        const values = getLoadedValues({ outputs });\n        reset(values);\n        updateContext({ isLoading: false, isDirty: true });\n        const valid = await control.trigger();\n        if (valid) {\n            composeRequest();\n        }\n    };\n\n    // get response from ReviewTransaction modal\n    const sign = useCallback(async () => {\n        const values = getValues();\n        const composedTx = composedLevels\n            ? composedLevels[values.selectedFee || 'normal']\n            : undefined;\n        if (composedTx && composedTx.type === 'final') {\n            // sign workflow in Actions:\n            // signTransaction > sign[COIN]Transaction > requestPushTransaction (modal with promise decision)\n            updateContext({ isLoading: true });\n            const result = await signTransaction(values, composedTx);\n            updateContext({ isLoading: false });\n            if (result) {\n                resetContext();\n            }\n        }\n    }, [getValues, composedLevels, signTransaction, resetContext, updateContext]);\n\n    const typedRegister = useCallback(<T>(rules?: T) => register(rules), [register]);\n\n    // load draft from reducer\n    useEffect(() => {\n        const storedState = getDraft();\n        const values = getLoadedValues(storedState);\n        reset(values);\n\n        if (storedState) {\n            draft.current = storedState;\n        }\n    }, [getDraft, getLoadedValues, reset]);\n\n    // register custom form fields (without HTMLElement)\n    useEffect(() => {\n        register({ name: 'setMaxOutputId', type: 'custom' });\n        register({ name: 'options', type: 'custom' });\n    }, [register]);\n\n    // handle draft change\n    useEffect(() => {\n        if (!draft.current) return;\n        composeDraft(draft.current);\n        draft.current = undefined;\n    }, [draft, composeDraft]);\n\n    // handle draftSaveRequest\n    useEffect(() => {\n        if (!draftSaveRequest) return;\n        if (Object.keys(errors).length === 0) {\n            saveDraft(getValues());\n        }\n        setDraftSaveRequest(false);\n    }, [draftSaveRequest, setDraftSaveRequest, saveDraft, getValues, errors]);\n\n    return {\n        ...state,\n        ...useFormMethods,\n        register: typedRegister,\n        outputs: outputsFieldArray.fields,\n        composedLevels,\n        updateContext,\n        resetContext,\n        changeFeeLevel,\n        composeTransaction: composeRequest,\n        loadTransaction,\n        signTransaction: sign,\n        ...sendFormUtils,\n        ...sendFormOutputs,\n    };\n};\n\n// Used across send form components\n// Provide combined context of `react-hook-form` with custom values as SendContextValues\nexport const useSendFormContext = () => {\n    const ctx = useContext(SendContext);\n    if (ctx === null) throw Error('useSendFormContext used without Context');\n    return ctx;\n};\n","import { useCallback } from 'react';\nimport { UseFormMethods } from 'react-hook-form';\nimport { toFiatCurrency } from '@wallet-utils/fiatConverterUtils';\nimport {\n    FormState,\n    FormOptions,\n    UseSendFormState,\n    SendContextValues,\n} from '@wallet-types/sendForm';\nimport { isEnabled as isFeatureEnabled } from '@suite-utils/features';\n\ntype Props = UseFormMethods<FormState> & {\n    fiatRates: UseSendFormState['fiatRates'];\n};\n\n// This hook should be used only as a sub-hook of `useSendForm`\n\nexport const useSendFormFields = ({\n    control,\n    getValues,\n    setValue,\n    clearErrors,\n    fiatRates,\n}: Props) => {\n    const calculateFiat = useCallback(\n        (outputIndex: number, amount?: string) => {\n            const { outputs } = getValues();\n            const output = outputs ? outputs[outputIndex] : undefined;\n            if (!output || output.type !== 'payment') return;\n            const { fiat, currency } = output;\n            if (typeof fiat !== 'string') return; // fiat input not registered (testnet or fiat not available)\n            const inputName = `outputs[${outputIndex}].fiat`;\n            if (!amount) {\n                // reset fiat value (Amount field has error)\n                if (fiat.length > 0) {\n                    setValue(inputName, '');\n                }\n                return;\n            }\n            // calculate Fiat value\n            if (!fiatRates || !fiatRates.current) return;\n            const fiatValue = toFiatCurrency(amount, currency.value, fiatRates.current.rates);\n            if (fiatValue) {\n                setValue(inputName, fiatValue, { shouldValidate: true });\n            }\n        },\n        [getValues, setValue, fiatRates],\n    );\n\n    const setAmount = useCallback(\n        (outputIndex: number, amount: string) => {\n            setValue(`outputs[${outputIndex}].amount`, amount, {\n                shouldValidate: amount.length > 0,\n                shouldDirty: true,\n            });\n            calculateFiat(outputIndex, amount);\n        },\n        [calculateFiat, setValue],\n    );\n\n    const setMax = useCallback(\n        (outputIndex: number, active: boolean) => {\n            clearErrors([`outputs[${outputIndex}].amount`, `outputs[${outputIndex}].fiat`]);\n            if (!active) {\n                setValue(`outputs[${outputIndex}].amount`, '');\n                setValue(`outputs[${outputIndex}].fiat`, '');\n            }\n            setValue('setMaxOutputId', active ? undefined : outputIndex);\n        },\n        [clearErrors, setValue],\n    );\n\n    const resetDefaultValue = useCallback(\n        (fieldName: string) => {\n            // Since some fields are registered conditionally (locktime, rippleDestinationTag etc..)\n            // they will set defaultValue from draft on every mount\n            // to prevent that behavior reset defaultValue in `react-hook-form.control.defaultValuesRef`\n            const { current } = control.defaultValuesRef;\n            // @ts-ignore: react-hook-form type returns \"unknown\" (bug?)\n            if (current && current[fieldName]) current[fieldName] = '';\n            // reset current value\n            setValue(fieldName, '');\n            // clear error\n            clearErrors(fieldName);\n        },\n        [control, setValue, clearErrors],\n    );\n\n    // `outputs[x].fieldName` should be a regular `formState` value from `getValues()` method\n    // however `useFieldArray` doesn't provide it BEFORE input is registered (it will be undefined on first render)\n    // use fallbackValue from useFieldArray.fields if so, because `useFieldArray` architecture requires `defaultValue` to be provided for registered inputs\n    const getDefaultValue: SendContextValues['getDefaultValue'] = <K extends string, T = undefined>(\n        fieldName: K,\n        fallbackValue?: T,\n    ) => {\n        if (fallbackValue !== undefined) {\n            const stateValue = getValues<K, T>(fieldName);\n            if (stateValue !== undefined) return stateValue;\n            return fallbackValue;\n        }\n        return getValues<K, T>(fieldName);\n    };\n\n    const toggleOption = (option: FormOptions) => {\n        if (!isFeatureEnabled('RBF') && option === 'bitcoinRBF') {\n            // do not use RBF if disabled\n            return;\n        }\n        const enabledOptions = getValues('options') || [];\n        const isEnabled = enabledOptions.includes(option);\n        if (isEnabled) {\n            setValue(\n                'options',\n                enabledOptions.filter(o => o !== option),\n            );\n        } else {\n            setValue('options', [...enabledOptions, option]);\n        }\n    };\n\n    return {\n        calculateFiat,\n        setAmount,\n        resetDefaultValue,\n        setMax,\n        getDefaultValue,\n        toggleOption,\n    };\n};\n","import { useState, useRef, useEffect, useCallback } from 'react';\nimport { UseFormMethods } from 'react-hook-form';\nimport {\n    FormState,\n    UseSendFormState,\n    SendContextValues,\n    PrecomposedTransaction,\n} from '@wallet-types/sendForm';\nimport { useActions, useAsyncDebounce } from '@suite-hooks';\nimport * as sendFormActions from '@wallet-actions/sendFormActions';\nimport { findComposeErrors } from '@wallet-utils/sendFormUtils';\n\ntype Props = UseFormMethods<FormState> & {\n    state: UseSendFormState;\n    account: UseSendFormState['account']; // account from the component props !== state.account\n    updateContext: SendContextValues['updateContext'];\n    setAmount: (index: number, amount: string) => void;\n};\n\n// This hook should be used only as a sub-hook of `useSendForm`\nexport const useSendFormCompose = ({\n    getValues,\n    setValue,\n    setError,\n    errors,\n    clearErrors,\n    state,\n    account,\n    updateContext,\n    setAmount,\n}: Props) => {\n    const [composedLevels, setComposedLevels] = useState<SendContextValues['composedLevels']>(\n        undefined,\n    );\n    const composeRequestRef = useRef<string | undefined>(undefined); // input name, caller of compose request\n    const composeRequestID = useRef(0); // compose ID, incremented with every compose request\n    const [composeField, setComposeField] = useState<string | undefined>(undefined);\n    const [draftSaveRequest, setDraftSaveRequest] = useState(false);\n\n    const debounce = useAsyncDebounce();\n\n    const { composeTransaction } = useActions({\n        composeTransaction: sendFormActions.composeTransaction,\n    });\n\n    const composeDraft = useCallback(\n        async (values: FormState) => {\n            // start composing without debounce\n            updateContext({ isLoading: true, isDirty: true });\n            setComposedLevels(undefined);\n            const result = await composeTransaction(values, state);\n            setComposedLevels(result);\n            updateContext({ isLoading: false, isDirty: true }); // isDirty needs to be set again, \"state\" is cached in updateContext callback\n        },\n        [state, composeTransaction, updateContext],\n    );\n\n    // called from composeRequest useEffect\n    const processComposeRequest = useCallback(async () => {\n        // eslint-disable-next-line require-await\n        const composeInner = async () => {\n            if (Object.keys(errors).length > 0) return;\n            const values = getValues();\n            // save draft (it could be changed later, after composing)\n            setDraftSaveRequest(true);\n            return composeTransaction(values, state);\n        };\n\n        // store current request ID before async debounced process and compare it later. see explanation below\n        const resultID = composeRequestID.current;\n        const result = await debounce(composeInner);\n        // RACE-CONDITION NOTE:\n        // resultID could be outdated when composeRequestID was updated by another upcoming/pending composeRequest and render tick didn't process it yet,\n        // therefore another debounce process was not called yet to interrupt current one\n        // unexpected result: `updateComposedValues` is trying to work with updated/newer FormState\n        if (resultID === composeRequestID.current) {\n            if (result) {\n                // set new composed transactions\n                setComposedLevels(result);\n            }\n            // result undefined: (FormState got errors or sendFormActions got errors)\n            updateContext({ isLoading: false });\n        }\n    }, [state, updateContext, debounce, errors, getValues, composeTransaction]);\n\n    // Create a compose request which should be processed in useEffect below\n    // This function should be called from the UI (input.onChange, button.click etc...)\n    // react-hook-form doesn't propagate values immediately. New calculated FormState is available until render tick\n    // IMPORTANT NOTE: Processing request without useEffect will use outdated FormState values (FormState before input.onChange)\n    // NOTE: this function doesn't have to be wrapped in useCallback since no component is using it as a hook dependency and it will be cleared by garbage collector (useCallback are not)\n    const composeRequest = (field = 'outputs[0].amount') => {\n        // reset precomposed transactions\n        setComposedLevels(undefined);\n        // set ref for later use in useEffect which handle composedLevels change\n        composeRequestRef.current = field;\n        // set ref for later use in processComposeRequest function\n        composeRequestID.current++;\n        // clear errors from compose process\n        const composeErrors = findComposeErrors(errors);\n        if (composeErrors.length > 0) {\n            clearErrors(composeErrors);\n        }\n        // set state value for later use in updateComposedValues function\n        setComposeField(field);\n        // start composing\n        updateContext({ isLoading: true, isDirty: true });\n    };\n\n    // Handle composeRequest\n    useEffect(() => {\n        // compose request is not set, do nothing\n        if (!composeRequestRef.current) return;\n        processComposeRequest();\n        // reset compose request\n        composeRequestRef.current = undefined;\n    }, [composeRequestRef, processComposeRequest]);\n\n    // update fields AFTER composedLevels change or selectedFee change (below)\n    const updateComposedValues = useCallback(\n        (composed: PrecomposedTransaction) => {\n            const values = getValues();\n            if (composed.type === 'error') {\n                const { error, errorMessage } = composed;\n                if (!errorMessage) {\n                    // composed tx doesn't have an errorMessage (Translation props)\n                    // this error is unexpected and should be handled in sendFormActions\n                    console.warn('Compose unexpected error', error);\n                    return;\n                }\n\n                if (composeField) {\n                    // setError to the field which created `composeRequest`\n                    setError(composeField, {\n                        type: 'compose',\n                        message: errorMessage as any, // setError types is broken? according to ts it accepts only strings, but object or react component could be used as well...\n                    });\n                } else if (values.outputs) {\n                    // setError to the all `Amount` fields, composeField not specified (load draft case)\n                    values.outputs.forEach((_, i) => {\n                        setError(`outputs[${i}].amount`, {\n                            type: 'compose',\n                            message: errorMessage as any,\n                        });\n                    });\n                }\n                return;\n            }\n\n            const composeErrors = findComposeErrors(errors);\n            if (composeErrors.length > 0) {\n                clearErrors(composeErrors);\n            }\n\n            // update feeLimit field if present (calculated from ethereum data size)\n            setValue('estimatedFeeLimit', composed.estimatedFeeLimit);\n\n            const { setMaxOutputId } = values;\n            // set calculated and formatted \"max\" value to `Amount` input\n            if (typeof setMaxOutputId === 'number' && composed.max) {\n                setAmount(setMaxOutputId, composed.max);\n                setDraftSaveRequest(true);\n            }\n        },\n        [composeField, getValues, setAmount, errors, setError, clearErrors, setValue],\n    );\n\n    // handle composedLevels change, setValues or errors for composeField\n    useEffect(() => {\n        // do nothing if there are no composedLevels\n        if (!composedLevels) return;\n\n        const values = getValues();\n        const { selectedFee, setMaxOutputId } = values;\n        let composed = composedLevels[selectedFee || 'normal'];\n\n        // selectedFee was not set yet (no interaction with Fees) and default (normal) fee tx is not valid\n        // OR setMax option was used\n        // try to switch to nearest possible composed transaction\n        const shouldSwitch =\n            !selectedFee || (typeof setMaxOutputId === 'number' && selectedFee !== 'custom');\n        if (shouldSwitch && composed.type === 'error') {\n            // find nearest possible tx\n            const nearest = Object.keys(composedLevels).find(\n                key => composedLevels[key].type !== 'error',\n            );\n            // switch to it\n            if (nearest) {\n                composed = composedLevels[nearest];\n                setValue('selectedFee', nearest);\n                if (nearest === 'custom') {\n                    // @ts-ignore: type = error already filtered above\n                    const { feePerByte, feeLimit } = composed;\n                    setValue('feePerUnit', feePerByte);\n                    setValue('feeLimit', feeLimit);\n                }\n                setDraftSaveRequest(true);\n            }\n            // or do nothing, use default composed tx\n        }\n\n        // composed transaction does not exists (not going to happen?)\n        if (!composed) {\n            return;\n        }\n\n        updateComposedValues(composed);\n    }, [composedLevels, getValues, setValue, updateComposedValues]);\n\n    // called from the useFees sub-hook\n    const onFeeLevelChange = useCallback(\n        (prev: FormState['selectedFee'], current: FormState['selectedFee']) => {\n            if (!composedLevels) return;\n            if (current === 'custom') {\n                // set custom level from previously selected level\n                const prevLevel = composedLevels[prev || 'normal'];\n                setComposedLevels({\n                    ...composedLevels,\n                    custom: prevLevel,\n                });\n            } else {\n                const currentLevel = composedLevels[current || 'normal'];\n                updateComposedValues(currentLevel);\n            }\n            updateContext({ isDirty: true });\n            setDraftSaveRequest(true);\n        },\n        [composedLevels, updateComposedValues, updateContext],\n    );\n\n    // handle props.account change:\n    // - update context state (state.account)\n    // - compose transaction with new data\n    useEffect(() => {\n        if (state.account === account) return; // account didn't change\n        if (!state.isDirty) {\n            // there was no interaction with the form, just update state.account\n            updateContext({ account });\n            return;\n        }\n\n        // reset precomposed transactions\n        setComposedLevels(undefined);\n        // set ref for later use in useEffect which handle composedLevels change\n        composeRequestRef.current = 'outputs[0].amount';\n        // set ref for later use in processComposeRequest function\n        composeRequestID.current++;\n        // clear errors from compose process\n        const composeErrors = findComposeErrors(errors);\n        if (composeErrors.length > 0) {\n            clearErrors(composeErrors);\n        }\n        // start composing\n        updateContext({ account, isLoading: true });\n    }, [state.account, state.isDirty, account, clearErrors, errors, updateContext]);\n\n    return {\n        composeDraft,\n        composeRequest,\n        draftSaveRequest,\n        setDraftSaveRequest,\n        composedLevels,\n        setComposedLevels,\n        onFeeLevelChange,\n    };\n};\n","import { useCallback, useEffect } from 'react';\nimport { useFieldArray, UseFormMethods } from 'react-hook-form';\nimport { FormState, UseSendFormState, SendContextValues } from '@wallet-types/sendForm';\nimport { DEFAULT_PAYMENT, DEFAULT_OPRETURN } from '@wallet-constants/sendForm';\n\ntype Props = UseFormMethods<FormState> & {\n    outputsFieldArray: ReturnType<typeof useFieldArray>;\n    localCurrencyOption: UseSendFormState['localCurrencyOption'];\n    composeRequest: SendContextValues['composeTransaction'];\n};\n\n// This hook should be used only as a sub-hook of `useSendForm`\n\nexport const useSendFormOutputs = ({\n    outputsFieldArray,\n    register,\n    unregister,\n    getValues,\n    setValue,\n    reset,\n    clearErrors,\n    localCurrencyOption,\n    composeRequest,\n}: Props) => {\n    const addOutput = useCallback(() => {\n        outputsFieldArray.append({\n            ...DEFAULT_PAYMENT,\n            currency: localCurrencyOption,\n        });\n    }, [localCurrencyOption, outputsFieldArray]);\n\n    const removeOutput = useCallback(\n        (index: number) => {\n            const values = getValues();\n            const { setMaxOutputId } = values;\n            if (setMaxOutputId === index) {\n                // reset setMaxOutputId\n                setValue('setMaxOutputId', undefined);\n            }\n            if (typeof setMaxOutputId === 'number' && setMaxOutputId > index) {\n                // reduce setMaxOutputId\n                setValue('setMaxOutputId', setMaxOutputId - 1);\n            }\n\n            // TEMP: reset values for the Output which will be removed\n            // react-hook-form somehow keeps cached values which has been set \"from the outside\" using setValue TODO: investigate more\n            // use case example:\n            // add second Output > click \"send-max\" (calculated \"max\" value will be set after compose) > remove second Output > add second Output again\n            setValue(`outputs[${index}]`, DEFAULT_PAYMENT);\n            outputsFieldArray.remove(index);\n        },\n        [getValues, setValue, outputsFieldArray],\n    );\n\n    const addOpReturn = () => {\n        // const outputs = getValues('outputs');\n        const values = getValues();\n        const lastOutput = values.outputs[values.outputs.length - 1];\n        const isLastOutputDirty = lastOutput.address.length > 0 || lastOutput.amount.length > 0;\n        if (isLastOutputDirty) {\n            outputsFieldArray.append({ ...DEFAULT_OPRETURN });\n        } else {\n            reset(\n                {\n                    ...values,\n                    outputs: [DEFAULT_OPRETURN],\n                },\n                { errors: true },\n            );\n        }\n    };\n\n    const removeOpReturn = (index: number) => {\n        const values = getValues();\n        if (values.outputs.length > 1) {\n            removeOutput(index);\n        } else {\n            clearErrors('outputs[0]');\n            reset(\n                {\n                    ...values,\n                    outputs: [\n                        {\n                            ...DEFAULT_PAYMENT,\n                            currency: localCurrencyOption,\n                        },\n                    ],\n                },\n                { errors: true },\n            );\n        }\n        composeRequest('outputs[0].amount');\n    };\n\n    // each Output have additional uncontrolled values that needs to be present in FormState\n    // they need to be registered without any HTMLElement as a \"custom\" field\n    const { fields } = outputsFieldArray;\n    useEffect(() => {\n        fields.forEach((output, index) => {\n            register({ name: `outputs[${index}].type`, type: 'custom' });\n            // set defaultValues\n            setValue(`outputs[${index}].type`, output.type);\n        });\n        return () => {\n            // unregister fields\n            fields.forEach((_output, index) => {\n                unregister(`outputs[${index}].type`);\n            });\n        };\n    }, [fields, register, unregister, setValue]);\n\n    return {\n        addOutput,\n        removeOutput,\n        addOpReturn,\n        removeOpReturn,\n    };\n};\n","import * as sendFormActions from '@wallet-actions/sendFormActions';\nimport { useActions } from '@suite-hooks';\nimport { DEFAULT_PAYMENT } from '@wallet-constants/sendForm';\nimport { FIAT } from '@suite-config';\nimport { fromFiatCurrency, toFiatCurrency } from '@wallet-utils/fiatConverterUtils';\nimport { UseSendFormState, Output } from '@wallet-types/sendForm';\n\ntype Props = {\n    network: UseSendFormState['network'];\n    tokens: UseSendFormState['account']['tokens'];\n    fiatRates: UseSendFormState['fiatRates'];\n    localCurrencyOption: UseSendFormState['localCurrencyOption'];\n};\n\n// This hook should be used only as a sub-hook of `useSendForm`\n\nexport const useSendFormImport = ({ network, tokens, localCurrencyOption, fiatRates }: Props) => {\n    const { importRequest } = useActions({\n        importRequest: sendFormActions.importRequest,\n    });\n\n    const importTransaction = async () => {\n        // open ImportTransaction modal and get parsed csv\n        const result = await importRequest();\n        if (!result) return; // cancelled\n\n        const outputs = result.map(item => {\n            // create default Output with address from csv\n            const output: Output = {\n                ...DEFAULT_PAYMENT,\n                currency: localCurrencyOption,\n                address: item.address || '',\n            };\n\n            // currency is specified in csv\n            if (item.currency) {\n                // sanitize csv data\n                const currency = item.currency.toLowerCase();\n\n                if (currency === network.symbol) {\n                    // csv amount in crypto currency\n                    output.amount = item.amount || '';\n                    // calculate Fiat from Amount\n                    if (fiatRates && fiatRates.current) {\n                        output.fiat =\n                            toFiatCurrency(\n                                output.amount,\n                                output.currency.value,\n                                fiatRates.current.rates,\n                            ) || '';\n                    }\n                } else if (\n                    FIAT.currencies.find(c => c === currency) &&\n                    fiatRates &&\n                    fiatRates.current &&\n                    Object.keys(fiatRates.current.rates).includes(currency)\n                ) {\n                    // csv amount in fiat currency\n                    output.currency = { value: currency, label: currency.toUpperCase() };\n                    output.fiat = item.amount || '';\n                    // calculate Amount from Fiat\n                    output.amount =\n                        fromFiatCurrency(\n                            output.fiat,\n                            currency,\n                            fiatRates.current.rates,\n                            network.decimals,\n                        ) || '';\n                } else if (tokens) {\n                    // csv amount in ERC20 currency\n                    const token = tokens.find(t => t.symbol === currency);\n                    if (token) {\n                        output.token = token.address;\n                        output.amount = item.amount || '';\n                    }\n                }\n\n                if (!output.amount || !output.fiat) {\n                    // TODO: display Toast notification with invalid currency error?\n                    // what if there will be multiple errors? Toast spamming...\n                    console.warn('import error', currency, output);\n                }\n            }\n            return output;\n        });\n\n        // only one output allowed for ETH and XRP\n        // TODO: create queue of transactions to sign to allow multiple outputs for ETH/XRP (overkill?)\n        return network.networkType === 'bitcoin' ? outputs : [outputs[0]];\n    };\n\n    return {\n        importTransaction,\n    };\n};\n"],"sourceRoot":""}